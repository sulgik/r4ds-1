# 데이터 시각화 {#sec-data-visualization}

```{r}
#| results: "asis"
#| echo: false

source("_common.R")
status("complete")
```

## 들어가기

> "간단한 그래프는 데이터 분석가에게 다른 어떤 것보다도 많은 정보를 제공한다." --- 존 튜키 (John Tukey)

R 에서 그래프를 만드는 시스템이 몇명 있지만 이 중 가장 우아하고 다재다능한 시스템 중 하나는 ggplot2 이다.
ggplot2 에는 **그래픽 문법** 이 구현되어 있는데, 이는 그래프를 일관성 있게 기술하고 구현하는 시스템이다.
ggplot2 를 활용하여 하나의 시스템을 빠르게 배우고 여러 곳에 적용할 수 있다.

이 장에서는 **ggplot2** 를 이용하여 데이터를 시각화하는 법을 배울 것이다.
간단한 산점도를 만드는 것으로 시작하여 이를 사용하여 ggplot2 의 기본 구성 요소인 미적매핑과 기하학 개체를 소개하고, 일변수 분포를 시각화하고 두 개 이상의 변수 간의 관계를 시각화하는 방법을 안내한 다음, 플롯 저장 및 문제 해결 팁으로 마무리한다.

### 준비하기

이 장에서는 tidyverse 의 핵심 요소 중 하나인 ggplot2 를 집중적으로 살펴본다.
이 장에서 사용할 데이터셋, 도움말 페이지, 함수에 접근하기 위해 다음의 코드를 실행하여 tidyverse 를 로드하라:

```{r}
#| label: setup

library(tidyverse)
```

이 한 줄의 코드만 입력하면 tidyverse 핵심 패키지들이 로드되는데, 거의 모든 데이터 분석에서 이 패키지들을 사용할 것이다.
또한 이 코드는 tidyverse 의 어떤 함수가 베이스 R 함수들(혹은 이미 로드한 다른 패키지의 함수들)과 충돌하는지도 알려준다[^kr_data-visualize-1].

[^kr_data-visualize-1]: You can eliminate that message and force conflict resolution to happen on demand by using the conflicted package, which becomes more important as you load more packages.
    You can learn more about conflicted at <https://conflicted.r-lib.org>.

실행한 뒤 "there is no package called 'tidyverse'" 라는 오류 메시지가 뜨면 먼저 아래와 같이 패키지를 설치한 후 `library()` 를 다시 실행해야 한다.

```{r}
#| eval: false

install.packages("tidyverse")
library(tidyverse)
```

패키지는 한 번만 설치하면 되지만, 새로운 세션을 시작할 때마다 다시 로드해야 한다.

tidyverse 외에도 팔머 군도 3 개 섬에 서식하는 펭귄의 신체치수가 포함된 `penguins` 데이터셋이 포함된 **palmerpenguins** 패키지와 색맹친화 색상 팔레트를 제공하는 ggthemes 패키지도 함께 사용할 예정이다.

```{r}
library(palmerpenguins)
library(ggthemes)
```

## 첫 단계

날개가 긴 펭귄은 짧은 펭귄보다 더 몸무게가 더 크거나 작을까?
답을 이미 알고 있겠지만, 더 정확히 답해보자.
날개 길이와 몸무게의 관계는 어떨까?
양의 관계?
음의 관계?
선형?
비선형?
해당관계는 펭귄 종마다 다를까?
펭귄이 서식하는 섬을 고려하면 어떨까?
시각화를 생성하여 이러한 질문들을 해결해보자.

### `penguins` 데이터프레임

palmerpenguins 패키지의 `penguins` **데이터프레임** (즉, `palmerpenguins::penguins`)을 이용하여 이러한 질문들에 답할 수 있다.
데이터프레임은 변수들(열)과 관측값들(행)의 직사각형 형태 모음이다.
`penguins` 에는 Kristen Gorman 박사와 남극 Palmer 기지 LTER이 수집하고 제공한 `r nrow(penguins)` 개의 관측값들이 있다 [^kr_data-visualize-2].

[^kr_data-visualize-2]: Horst AM, Hill AP, Gorman KB (2020).
    palmerpenguins: Palmer Archipelago (Antarctica) penguin data.
    R package version 0.1.0.
    <https://allisonhorst.github.io/palmerpenguins/>.
    doi: 10.5281/zenodo.3960218.

논의를 수월하게 하기 위해, 용어들을 정의해 보자.

-   **변수** is a quantity, quality, or property that you can measure.

-   **값** is the state of a variable when you measure it.
    The value of a variable may change from measurement to measurement.

-   An **observation** is a set of measurements made under similar conditions (you usually make all of the measurements in an observation at the same time and on the same object).
    An observation will contain several values, each associated with a different variable.
    We'll sometimes refer to an observation as a data point.

-   **테이블 데이터(tabular data)** is a set of values, each associated with a variable and an observation.
    Tabular data is *tidy* if each value is placed in its own "cell", each variable in its own column, and each observation in its own row.

In this context, a variable refers to an attribute of all the penguins, and an observation refers to all the attributes of a single penguin.

Type the name of the data frame in the console and R will print a preview of its contents.
Note that it says `tibble` on top of this preview.
In the tidyverse, we use special data frames called **tibbles** that you will learn more about soon.

```{r}
penguins
```

이 데이터프레임에는 `r ncol(penguins)` 개의 열이 있습니다.
For an alternative view, where you can see all variables and the first few observations of each variable, use `glimpse()`.
Or, if you're in RStudio, click on the name of the data frame in the Environment pane or run `View(penguins)` to open an interactive data viewer.

```{r}
glimpse(penguins)
```

`penguins` 에는 다음 변수들이 포함되어 있습니다:

1.  `species`: 펭귄종 (Adelie, Chinstrap, \Gentoo).

2.  `flipper_length_mm`: 펭귄 날개 길이 (단위: 밀리미터).

3.  `body_mass_g`: 펭귄 몸무게 (단위: 그램).

To learn more about `penguins`, open its help page by running `?penguins`.

### Ultimate goal {#sec-ultimate-goal}

Our ultimate goal in this chapter is to recreate the following visualization displaying the relationship between flipper lengths and body masses of these penguins, taking into consideration the species of the penguin.

```{r}
#| echo: false
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins, with a
#|   best fit line of the relationship between these two variables 
#|   overlaid. The plot displays a positive, fairly linear, and relatively 
#|   strong relationship between these two variables. Species (Adelie, 
#|   Chinstrap, and Gentoo) are represented with different colors and 
#|   shapes. The relationship between body mass and flipper length is 
#|   roughly the same for these three species, and Gentoo penguins are 
#|   larger than penguins from the other two species.

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)",
    y = "Body mass (g)",
    color = "Species",
    shape = "Species"
  ) +
  scale_color_colorblind()
```

### Creating a ggplot

Let's recreate this plot step-by-step.

With ggplot2, you begin a plot with the function `ggplot()`, defining a plot object that you then add **layers** to.
The first argument of `ggplot()` is the dataset to use in the graph and so `ggplot(data = penguins)` creates an empty graph that is primed to display the `penguins` data, but since we haven't told it how to visualize it yet, for now it's empty.
This is not a very exciting plot, but you can think of it like an empty canvas you'll paint the remaining layers of your plot onto.

```{r}
#| fig-alt: >
#|   A blank, gray plot area.

ggplot(data = penguins)
```

Next, we need to tell `ggplot()` how the information from our data will be visually represented.
The `mapping` argument of the `ggplot()` function defines how variables in your dataset are mapped to visual properties (**aesthetics**) of your plot.
The `mapping` argument is always defined in the `aes()` function, and the `x` and `y` arguments of `aes()` specify which variables to map to the x and y axes.
For now, we will only map flipper length to the `x` aesthetic and body mass to the `y` aesthetic.
ggplot2 looks for the mapped variables in the `data` argument, in this case, `penguins`.

The following plot shows the result of adding these mappings.

```{r}
#| fig-alt: >
#|   The plot shows flipper length on the x-axis, with values that range from 
#|   170 to 230, and body mass on the y-axis, with values that range from 3000 
#|   to 6000.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
)
```

Our empty canvas now has more structure -- it's clear where flipper lengths will be displayed (on the x-axis) and where body masses will be displayed (on the y-axis).
But the penguins themselves are not yet on the plot.
This is because we have not yet articulated, in our code, how to represent the observations from our data frame on our plot.

To do so, we need to define a **geom**: the geometrical object that a plot uses to represent data.
These geometric objects are made available in ggplot2 with functions that start with `geom_`.
People often describe plots by the type of geom that the plot uses.
For example, bar charts use bar geoms (`geom_bar()`), line charts use line geoms (`geom_line()`), boxplots use boxplot geoms (`geom_boxplot()`), scatterplots use point geoms (`geom_point()`), and so on.

The function `geom_point()` adds a layer of points to your plot, which creates a scatterplot.
ggplot2 comes with many geom functions that each adds a different type of layer to a plot.
You'll learn a whole bunch of geoms throughout the book, particularly in @sec-layers.

```{r}
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, and relatively strong relationship between 
#|   these two variables.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Now we have something that looks like what we might think of as a "scatter plot".
It doesn't yet match our "ultimate goal" plot, but using this plot we can start answering the question that motivated our exploration: "What does the relationship between flipper length and body mass look like?" The relationship appears to be positive (as flipper length increases, so does body mass), fairly linear (the points are clustered around a line instead of a curve), and moderately strong (there isn't too much scatter around such a line).
Penguins with longer flippers are generally larger in terms of their body mass.

Before we add more layers to this plot, let's pause for a moment and review the warning message we got:

> Removed 2 rows containing missing values (`geom_point()`).

We're seeing this message because there are two penguins in our dataset with missing body mass and/or flipper length values and ggplot2 has no way of representing them on the plot without both of these values.
Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing.
This type of warning is probably one of the most common types of warnings you will see when working with real data -- missing values are a very common issue and you'll learn more about them throughout the book, particularly in @sec-missing-values.
For the remaining plots in this chapter we will suppress this warning so it's not printed alongside every single plot we make.

### Adding aesthetics and layers {#sec-adding-aesthetics-layers}

Scatterplots are useful for displaying the relationship between two numerical variables, but it's always a good idea to be skeptical of any apparent relationship between two variables and ask if there may be other variables that explain or change the nature of this apparent relationship.
For example, does the relationship between flipper length and body mass differ by species?
Let's incorporate species into our plot and see if this reveals any additional insights into the apparent relationship between these variables.
We will do this by representing species with different colored points.

To achieve this, will we need to modify the aesthetic or the geom?
If you guessed "in the aesthetic mapping, inside of `aes()`", you're already getting the hang of creating data visualizations with ggplot2!
And if not, don't worry.
Throughout the book you will make many more ggplots and have many more opportunities to check your intuition as you make them.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, fairly linear, and relatively strong relationship 
#|   between these two variables. Species (Adelie, Chinstrap, and Gentoo) 
#|   are represented with different colors.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point()
```

When a categorical variable is mapped to an aesthetic, ggplot2 will automatically assign a unique value of the aesthetic (here a unique color) to each unique level of the variable (each of the three species), a process known as **scaling**.
ggplot2 will also add a legend that explains which values correspond to which levels.

Now let's add one more layer: a smooth curve displaying the relationship between body mass and flipper length.
Before you proceed, refer back to the code above, and think about how we can add this to our existing plot.

Since this is a new geometric object representing our data, we will add a new geom as a layer on top of our point geom: `geom_smooth()`.
And we will specify that we want to draw the line of best fit based on a `l`inear `m`odel with `method = "lm"`.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot are three smooth curves displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors for the points and the smooth curves.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point() +
  geom_smooth(method = "lm")
```

We have successfully added lines, but this plot doesn't look like the plot from @sec-ultimate-goal, which only has one line for the entire dataset as opposed to separate lines for each of the penguin species.

When aesthetic mappings are defined in `ggplot()`, at the *global* level, they're passed down to each of the subsequent geom layers of the plot.
However, each geom function in ggplot2 can also take a `mapping` argument, which allows for aesthetic mappings at the *local* level that are added to those inherited from the global level.
Since we want points to be colored based on species but don't want the lines to be separated out for them, we should specify `color = species` for `geom_point()` only.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot is a single line of best fit displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors for the points only.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth(method = "lm")
```

Voila!
We have something that looks very much like our ultimate goal, though it's not yet perfect.
We still need to use different shapes for each species of penguins and improve labels.

It's generally not a good idea to represent information using only colors on a plot, as people perceive colors differently due to color blindness or other color vision differences.
Therefore, in addition to color, we can also map `species` to the `shape` aesthetic.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. Overlaid 
#|   on the scatterplot is a single line of best fit displaying the 
#|   relationship between these variables for each species (Adelie, 
#|   Chinstrap, and Gentoo). Different penguin species are plotted in 
#|   different colors and shapes for the points only.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth(method = "lm")
```

Note that the legend is automatically updated to reflect the different shapes of the points as well.

And finally, we can improve the labels of our plot using the `labs()` function in a new layer.
Some of the arguments to `labs()` might be self explanatory: `title` adds a title and `subtitle` adds a subtitle to the plot.
Other arguments match the aesthetic mappings, `x` is the x-axis label, `y` is the y-axis label, and `color` and `shape` define the label for the legend.
In addition, we can improve the color palette to be colorblind safe with the `scale_color_colorblind()` function from the ggthemes package.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins, with a 
#|   line of best fit displaying the relationship between these two variables 
#|   overlaid. The plot displays a positive, fairly linear, and relatively 
#|   strong relationship between these two variables. Species (Adelie, 
#|   Chinstrap, and Gentoo) are represented with different colors and 
#|   shapes. The relationship between body mass and flipper length is 
#|   roughly the same for these three species, and Gentoo penguins are 
#|   larger than penguins from the other two species.

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Body mass and flipper length",
    subtitle = "Dimensions for Adelie, Chinstrap, and Gentoo Penguins",
    x = "Flipper length (mm)", y = "Body mass (g)",
    color = "Species", shape = "Species"
  ) +
  scale_color_colorblind()
```

We finally have a plot that perfectly matches our "ultimate goal"!

### Exercises

1.  How many rows are in `penguins`?
    How many columns?

2.  What does the `bill_depth_mm` variable in the `penguins` data frame describe?
    Read the help for `?penguins` to find out.

3.  Make a scatterplot of `bill_depth_mm` vs. `bill_length_mm`.
    That is, make a scatterplot with `bill_depth_mm` on the y-axis and `bill_length_mm` on the x-axis.
    Describe the relationship between these two variables.

4.  What happens if you make a scatterplot of `species` vs. `bill_depth_mm`?
    What might be a better choice of geom?

5.  Why does the following give an error and how would you fix it?

    ```{r}
    #| eval: false

    ggplot(data = penguins) + 
      geom_point()
    ```

6.  What does the `na.rm` argument do in `geom_point()`?
    What is the default value of the argument?
    Create a scatterplot where you successfully use this argument set to `TRUE`.

7.  Add the following caption to the plot you made in the previous exercise: "Data come from the palmerpenguins package." Hint: Take a look at the documentation for `labs()`.

8.  Recreate the following visualization.
    What aesthetic should `bill_depth_mm` be mapped to?
    And should it be mapped at the global level or at the geom level?

    ```{r}
    #| echo: false
    #| warning: false
    #| fig-alt: >
    #|   A scatterplot of body mass vs. flipper length of penguins, colored 
    #|   by bill depth. A smooth curve of the relationship between body mass 
    #|   and flipper length is overlaid. The relationship is positive, 
    #|   fairly linear, and moderately strong.

    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g)
    ) +
      geom_point(aes(color = bill_depth_mm)) +
      geom_smooth()
    ```

9.  Run this code in your head and predict what the output will look like.
    Then, run the code in R and check your predictions.

    ```{r}
    #| eval: false

    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)
    ) +
      geom_point() +
      geom_smooth(se = FALSE)
    ```

10. Will these two graphs look different?
    Why/why not?

    ```{r}
    #| eval: false

    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g)
    ) +
      geom_point() +
      geom_smooth()

    ggplot() +
      geom_point(
        data = penguins,
        mapping = aes(x = flipper_length_mm, y = body_mass_g)
      ) +
      geom_smooth(
        data = penguins,
        mapping = aes(x = flipper_length_mm, y = body_mass_g)
      )
    ```

## ggplot2 호출 {#sec-ggplot2-calls}

As we move on from these introductory sections, we'll transition to a more concise expression of ggplot2 code.
So far we've been very explicit, which is helpful when you are learning:

```{r}
#| eval: false

ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Typically, the first one or two arguments to a function are so important that you should know them by heart.
The first two arguments to `ggplot()` are `data` and `mapping`, in the remainder of the book, we won't supply those names.
That saves typing, and, by reducing the amount of extra text, makes it easier to see what's different between plots.
That's a really important programming concern that we'll come back to in @sec-functions.

Rewriting the previous plot more concisely yields:

```{r}
#| eval: false

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

In the future, you'll also learn about the pipe, `|>`, which will allow you to create that plot with:

```{r}
#| eval: false

penguins |> 
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

## Visualizing distributions

How you visualize the distribution of a variable depends on the type of variable: categorical or numerical.

### A categorical variable

A variable is **categorical** if it can only take one of a small set of values.
To examine the distribution of a categorical variable, you can use a bar chart.
The height of the bars displays how many observations occurred with each `x` value.

```{r}
#| fig-alt: >
#|   A bar chart of frequencies of species of penguins: Adelie 
#|   (approximately 150), Chinstrap (approximately 90), Gentoo 
#|   (approximately 125).

ggplot(penguins, aes(x = species)) +
  geom_bar()
```

In bar plots of categorical variables with non-ordered levels, like the penguin `species` above, it's often preferable to reorder the bars based on their frequencies.
Doing so requires transforming the variable to a factor (how R handles categorical data) and then reordering the levels of that factor.

```{r}
#| fig-alt: >
#|   A bar chart of frequencies of species of penguins, where the bars are 
#|   ordered in decreasing order of their heights (frequencies): Adelie 
#|   (approximately 150), Gentoo (approximately 125), Chinstrap 
#|   (approximately 90).

ggplot(penguins, aes(x = fct_infreq(species))) +
  geom_bar()
```

You will learn more about factors and functions for dealing with factors (like `fct_infreq()` shown above) in @sec-factors.

### A numerical variable

A variable is **numerical** (or quantitative) if it can take on a wide range of numerical values, and it is sensible to add, subtract, or take averages with those values.
Numerical variables can be continuous or discrete.

One commonly used visualization for distributions of continuous variables is a histogram.

```{r}
#| warning: false
#| fig-alt: >
#|   A histogram of body masses of penguins. The distribution is unimodal 
#|   and right skewed, ranging between approximately 2500 to 6500 grams.

ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200)
```

A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin.
In the graph above, the tallest bar shows that 39 observations have a `body_mass_g` value between 3,500 and 3,700 grams, which are the left and right edges of the bar.

You can set the width of the intervals in a histogram with the binwidth argument, which is measured in the units of the `x` variable.
You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns.
In the plots below a binwidth of 20 is too narrow, resulting in too many bars, making it difficult to determine the shape of the distribution.
Similarly, a binwidth of 2,000 is too high, resulting in all data being binned into only three bars, and also making it difficult to determine the shape of the distribution.
A binwidth of 200 provides a sensible balance.

```{r}
#| warning: false
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: >
#|   Two histograms of body masses of penguins, one with binwidth of 20 
#|   (left) and one with binwidth of 2000 (right). The histogram with binwidth 
#|   of 20 shows lots of ups and downs in the heights of the bins, creating a 
#|   jagged outline. The histogram  with binwidth of 2000 shows only three bins.

ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20)
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000)
```

An alternative visualization for distributions of numerical variables is a density plot.
A density plot is a smoothed-out version of a histogram and a practical alternative, particularly for continuous data that comes from an underlying smooth distribution.
We won't go into how `geom_density()` estimates the density (you can read more about that in the function documentation), but let's explain how the density curve is drawn with an analogy.
Imagine a histogram made out of wooden blocks.
Then, imagine that you drop a cooked spaghetti string over it.
The shape the spaghetti will take draped over blocks can be thought of as the shape of the density curve.
It shows fewer details than a histogram but can make it easier to quickly glean the shape of the distribution, particularly with respect to modes and skewness.

```{r}
#| fig-alt: >
#|   A density plot of body masses of penguins. The distribution is unimodal 
#|   and right skewed, ranging between approximately 2500 to 6500 grams.

ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()
```

### Exercises

1.  Make a bar plot of `species` of `penguins`, where you assign `species` to the `y` aesthetic.
    How is this plot different?

2.  How are the following two plots different?
    Which aesthetic, `color` or `fill`, is more useful for changing the color of bars?

    ```{r}
    #| eval: false

    ggplot(penguins, aes(x = species)) +
      geom_bar(color = "red")

    ggplot(penguins, aes(x = species)) +
      geom_bar(fill = "red")
    ```

3.  What does the `bins` argument in `geom_histogram()` do?

4.  Make a histogram of the `carat` variable in the `diamonds` dataset that is available when you load the tidyverse package.
    Experiment with different binwidths.
    What binwidth reveals the most interesting patterns?

## Visualizing relationships

To visualize a relationship we need to have at least two variables mapped to aesthetics of a plot.
In the following sections you will learn about commonly used plots for visualizing relationships between two or more variables and the geoms used for creating them.

### A numerical and a categorical variable

To visualize the relationship between a numerical and a categorical variable we can use side-by-side box plots.
A **boxplot** is a type of visual shorthand for measures of position (percentiles) that describe a distribution.
It is also useful for identifying potential outliers.
As shown in @fig-eda-boxplot, each boxplot consists of:

-   A box that indicates the range of the middle half of the data, a distance known as the interquartile range (IQR), stretching from the 25th percentile of the distribution to the 75th percentile.
    In the middle of the box is a line that displays the median, i.e. 50th percentile, of the distribution.
    These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

-   Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box.
    These outlying points are unusual so are plotted individually.

-   A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

```{r}
#| label: fig-eda-boxplot
#| echo: false
#| fig-cap: >
#|   Diagram depicting how a boxplot is created.
#| fig-alt: >
#|   A diagram depicting how a boxplot is created following the steps outlined 
#|   above.

knitr::include_graphics("images/EDA-boxplot.png")
```

Let's take a look at the distribution of body mass by species using `geom_boxplot()`:

```{r}
#| warning: false
#| fig-alt: >
#|   Side-by-side box plots of distributions of body masses of Adelie, 
#|   Chinstrap, and Gentoo penguins. The distribution of Adelie and 
#|   Chinstrap penguins' body masses appear to be symmetric with 
#|   medians around 3750 grams. The median body mass of Gentoo penguins 
#|   is much higher, around 5000 grams, and the distribution of the 
#|   body masses of these penguins appears to be somewhat right skewed.

ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Alternatively, we can make density plots with `geom_density()`.

```{r}
#| warning: false
#| fig-alt: >
#|   A density plot of body masses of penguins by species of penguins. Each 
#|   species (Adelie, Chinstrap, and Gentoo) is represented with different 
#|   colored outlines for the density curves.

ggplot(penguins, aes(x = body_mass_g, color = species)) +
  geom_density(linewidth = 0.75)
```

We've also customized the thickness of the lines using the `linewidth` argument in order to make them stand out a bit more against the background.

Additionally, we can map `species` to both `color` and `fill` aesthetics and use the `alpha` aesthetic to add transparency to the filled density curves.
This aesthetic takes values between 0 (completely transparent) and 1 (completely opaque).
In the following plot it's *set* to 0.5.

```{r}
#| warning: false
#| fig-alt: >
#|   A density plot of body masses of penguins by species of penguins. Each 
#|   species (Adelie, Chinstrap, and Gentoo) is represented in different 
#|   colored outlines for the density curves. The density curves are also 
#|   filled with the same colors, with some transparency added.

ggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +
  geom_density(alpha = 0.5)
```

Note the terminology we have used here:

-   We *map* variables to aesthetics if we want the visual attribute represented by that aesthetic to vary based on the values of that variable.
-   Otherwise, we *set* the value of an aesthetic.

### Two categorical variables

We can use stacked bar plots to visualize the relationship between two categorical variables.
For example, the following two stacked bar plots both display the relationship between `island` and `species`, or specifically, visualizing the distribution of `species` within each island.

The first plot shows the frequencies of each species of penguins on each island.
The plot of frequencies show that there are equal numbers of Adelies on each island.
But we don't have a good sense of the percentage balance within each island.

```{r}
#| fig-alt: >
#|   Bar plots of penguin species by island (Biscoe, Dream, and Torgersen)
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
```

The second plot is a relative frequency plot, created by setting `position = "fill"` in the geom is more useful for comparing species distributions across islands since it's not affected by the unequal numbers of penguins across the islands.
Using this plot we can see that Gentoo penguins all live on Biscoe island and make up roughly 75% of the penguins on that island, Chinstrap all live on Dream island and make up roughly 50% of the penguins on that island, and Adelie live on all three islands and make up all of the penguins on Torgersen.

```{r}
#| fig-alt: >
#|   Bar plots of penguin species by island (Biscoe, Dream, and Torgersen)
#|   the bars are scaled to the same height, making it a relative frequencies 
#|   plot

ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill")
```

In creating these bar charts, we map the variable that will be separated into bars to the `x` aesthetic, and the variable that will change the colors inside the bars to the `fill` aesthetic.

### Two numerical variables

So far you've learned about scatterplots (created with `geom_point()`) and smooth curves (created with `geom_smooth()`) for visualizing the relationship between two numerical variables.
A scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, relatively strong relationship between 
#|   these two variables.

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
```

### Three or more variables

As we saw in @sec-adding-aesthetics-layers, we can incorporate more variables into a plot by mapping them to additional aesthetics.
For example, in the following scatterplot the colors of points represent species and the shapes of points represent islands.

```{r}
#| warning: false
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, relatively strong relationship between 
#|   these two variables. The points are colored based on the species of the 
#|   penguins and the shapes of the points represent islands (round points are 
#|   Biscoe island, triangles are Dream island, and squared are Torgersen 
#|   island). The plot is very busy and it's difficult to distinguish the shapes
#|   of the points.

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

However adding too many aesthetic mappings to a plot makes it cluttered and difficult to make sense of.
Another way, which is particularly useful for categorical variables, is to split your plot into **facets**, subplots that each display one subset of the data.

To facet your plot by a single variable, use `facet_wrap()`.
The first argument of `facet_wrap()` is a formula[^kr_data-visualize-3], which you create with `~` followed by a variable name.
The variable that you pass to `facet_wrap()` should be categorical.

[^kr_data-visualize-3]: Here "formula" is the name of the thing created by `~`, not a synonym for "equation".

```{r}
#| warning: false
#| fig-width: 8
#| fig-asp: 0.33
#| fig-alt: >
#|   A scatterplot of body mass vs. flipper length of penguins. The shapes and 
#|   colors of points represent species. Penguins from each island are on a 
#|   separate facet. Within each facet, the relationship between body mass and 
#|   flipper length is positive, linear, relatively strong. 

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  facet_wrap(~island)
```

You will learn about many other geoms for visualizing distributions of variables and relationships between them in @sec-layers.

### Exercises

1.  The `mpg` data frame that is bundled with the ggplot2 package contains `r nrow(mpg)` observations collected by the US Environmental Protection Agency on `r mpg |> distinct(model) |> nrow()` car models.
    Which variables in `mpg` are categorical?
    Which variables are numerical?
    (Hint: Type `?mpg` to read the documentation for the dataset.) How can you see this information when you run `mpg`?

2.  Make a scatterplot of `hwy` vs. `displ` using the `mpg` data frame.
    Next, map a third, numerical variable to `color`, then `size`, then both `color` and `size`, then `shape`.
    How do these aesthetics behave differently for categorical vs. numerical variables?

3.  In the scatterplot of `hwy` vs. `displ`, what happens if you map a third variable to `linewidth`?

4.  What happens if you map the same variable to multiple aesthetics?

5.  Make a scatterplot of `bill_depth_mm` vs. `bill_length_mm` and color the points by `species`.
    What does adding coloring by species reveal about the relationship between these two variables?
    What about faceting by species?

6.  Why does the following yield two separate legends?
    How would you fix it to combine the two legends?

    ```{r}
    #| warning: false
    #| fig-show: hide

    ggplot(
      data = penguins,
      mapping = aes(
        x = bill_length_mm, y = bill_depth_mm, 
        color = species, shape = species
      )
    ) +
      geom_point() +
      labs(color = "Species")
    ```

7.  Create the two following stacked bar plots.
    Which question can you answer with the first one?
    Which question can you answer with the second one?

    ```{r}
    #| fig-show: hide

    ggplot(penguins, aes(x = island, fill = species)) +
      geom_bar(position = "fill")
    ggplot(penguins, aes(x = species, fill = island)) +
      geom_bar(position = "fill")
    ```

## Saving your plots {#sec-ggsave}

Once you've made a plot, you might want to get it out of R by saving it as an image that you can use elsewhere.
That's the job of `ggsave()`, which will save the plot most recently created to disk:

```{r}
#| fig-show: hide
#| warning: false

ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
ggsave(filename = "penguin-plot.png")
```

```{r}
#| include: false

file.remove("penguin-plot.png")
```

This will save your plot to your working directory, a concept you'll learn more about in @sec-workflow-scripts-projects.

If you don't specify the `width` and `height` they will be taken from the dimensions of the current plotting device.
For reproducible code, you'll want to specify them.
You can learn more about `ggsave()` in the documentation.

Generally, however, we recommend that you assemble your final reports using Quarto, a reproducible authoring system that allows you to interleave your code and your prose and automatically include your plots in your write-ups.
You will learn more about Quarto in @sec-quarto.

### Exercises

1.  Run the following lines of code.
    Which of the two plots is saved as `mpg-plot.png`?
    Why?

    ```{r}
    #| eval: false

    ggplot(mpg, aes(x = class)) +
      geom_bar()
    ggplot(mpg, aes(x = cty, y = hwy)) +
      geom_point()
    ggsave("mpg-plot.png")
    ```

2.  What do you need to change in the code above to save the plot as a PDF instead of a PNG?
    How could you find out what types of image files would work in `ggsave()`?

## Common problems

As you start to run R code, you're likely to run into problems.
Don't worry --- it happens to everyone.
We have all been writing R code for years, but every day we still write code that doesn't work on the first try!

Start by carefully comparing the code that you're running to the code in the book.
R is extremely picky, and a misplaced character can make all the difference.
Make sure that every `(` is matched with a `)` and every `"` is paired with another `"`.
Sometimes you'll run the code and nothing happens.
Check the left-hand of your console: if it's a `+`, it means that R doesn't think you've typed a complete expression and it's waiting for you to finish it.
In this case, it's usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.

One common problem when creating ggplot2 graphics is to put the `+` in the wrong place: it has to come at the end of the line, not the start.
In other words, make sure you haven't accidentally written code like this:

```{r}
#| eval: false

ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))
```

If you're still stuck, try the help.
You can get help about any R function by running `?function_name` in the console, or highlighting the function name and pressing F1 in RStudio.
Don't worry if the help doesn't seem that helpful - instead skip down to the examples and look for code that matches what you're trying to do.

If that doesn't help, carefully read the error message.
Sometimes the answer will be buried there!
But when you're new to R, even if the answer is in the error message, you might not yet know how to understand it.
Another great tool is Google: try googling the error message, as it's likely someone else has had the same problem, and has gotten help online.

## Summary

In this chapter, you've learned the basics of data visualization with ggplot2.
We started with the basic idea that underpins ggplot2: a visualization is a mapping from variables in your data to aesthetic properties like position, color, size and shape.
You then learned about increasing the complexity and improving the presentation of your plots layer-by-layer.
You also learned about commonly used plots for visualizing the distribution of a single variable as well as for visualizing relationships between two or more variables, by levering additional aesthetic mappings and/or splitting your plot into small multiples using faceting.

We'll use visualizations again and again throughout this book, introducing new techniques as we need them as well as do a deeper dive into creating visualizations with ggplot2 in @sec-layers through @sec-communication.

With the basics of visualization under your belt, in the next chapter we're going to switch gears a little and give you some practical workflow advice.
We intersperse workflow advice with data science tools throughout this part of the book because it'll help you stay organized as you write increasing amounts of R code.
